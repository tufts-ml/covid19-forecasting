# Sampling code, towards ABC Sampler
Gian Marco Visani - 06/23/2020

## Simplified model and setup

The code thus far aims at recovering the parameters of a simulated patient trajectory, as simulated by our semimarkov-forecaster. This is done for simulations of 25 days and of 100 days.

Furthermore, for now we assume the number of presenting patients to be known, and thus we do not model it. We only aim to model the parameters of a categorical distribution over the time (duration) each patient spends in each state, given the health state of each patient, as well as the probability of the patient's health at each state. Thus, specify the number of presenting patients in a file that also specifies the number of timesteps (i.e. num_presenting_simple-##days.csv)

*True* summary statistics (census, admissions, etc.) are generated by `run_forecast.py`, which uses `PatientTrajectory.py`.

Specify the config file in the same manner as the current model, but append to the name the number of timesteps to simulate (i.e. params_simple-##days.json)

----------------------------------------------------------------------------------

## Sampling 

The sampling code is in file `sampling.py`. I have documented it as much as possible. Please reach out to me via email or slack if you have any questions!

What has been implemented:
    1) Running multiple simulations with a fixed set of parameters, in order to explore the average distance between the simulated and true summary statistics. It is especially important to try this with the *true* parameters that generated the simulated data.
    2) A simulated-annealing sampling procedure that accepts new parameters (theta) if they produce summary statistics that are closer to the truth than the current best parameters. This procedure achieves reasonable results.
    3) ABC Sampling procedure as described in https://arxiv.org/pdf/1001.2058.pdf and , Table 1.2. It currently does not work perfectly. I think I have implemented it correctly. I have tried by starting with a high value of epsilon and then annealing it over iterations. One issue is how to decide on a lower bound. Zero is not a viable option since it is basically impossible to achieve the same exact summary statistics even with the true parameters (try it yourself with my implementation that runs multiple simulations using the same parameters).

**Dependencies**
    - Those in semimarkov_forecaster.yml

Example run that gives decent parameter estimations:
    `python sampling.py --algorithm sa --num_timesteps 150 --num_simulations 5 --start_epsilon 150 --annealing_constant 0.996`

